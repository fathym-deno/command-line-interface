{
  "cli-build-static/cli.ts.hbs": "import { CLI, CLICommandResolver } from \"@fathym/common/cli\";\r\nimport { EmbeddedCLIFileSystemHooks } from \"./EmbeddedCLIFileSystemHooks.ts\";\r\n\r\nconst cli = new CLI({\r\n  resolver: new CLICommandResolver(new EmbeddedCLIFileSystemHooks()),\r\n});\r\n\r\ncli.RunFromArgs(Deno.args);\r\n",
  "cli-build-static/EmbeddedCLIFileSystemHooks.ts.hbs": "import type {\r\n  CLIFileSystemHooks,\r\n  CLIInitFn,\r\n  CLICommandEntry,\r\n  CommandModule,\r\n  CLIConfig,\r\n  TemplateLocator,\r\n} from \"@fathym/common/cli\";\r\nimport { CommandModuleBuilder, EmbeddedTemplateLocator } from \"@fathym/common/cli\";\r\nimport type { DFSFileHandler } from '@fathym/common/dfs';\r\n\r\nimport { fromFileUrl } from \"jsr:@std/path@^1.0.9/from-file-url\";\r\n\r\nimport embeddedConfig from \"../.cli.json\" with { type: \"json\" };\r\nimport embeddedTemplates from \"./embedded-templates.json\" with { type: \"json\" };\r\nimport embeddedCommandEntries from \"./embedded-command-entries.json\" with { type: \"json\" };\r\n\r\nimport { EmbeddedCommandModules } from \"./EmbeddedCommandModules.ts\";\r\n\r\n{{#if importInitFn}}\r\nimport embeddedInit from \"{{importInitFn}}\";\r\n{{/if}}\r\n\r\nexport class EmbeddedCLIFileSystemHooks implements CLIFileSystemHooks {\r\n  async ResolveCommandEntryPaths(\r\n    _baseCommandDir: string,\r\n  ): Promise<Map<string, CLICommandEntry>> {\r\n    const map = new Map<string, CLICommandEntry>(\r\n      Object.entries(embeddedCommandEntries as Record<string, CLICommandEntry>)\r\n    );\r\n    return map;\r\n  }\r\n\r\n  async ResolveConfig(args: string[]): Promise<{\r\n    config: CLIConfig;\r\n    resolvedPath: string;\r\n    remainingArgs: string[];\r\n  }> {\r\n    const remainingArgs = args[0]?.endsWith(\".json\") ? args.slice(1) : args;\r\n\r\n    return {\r\n      config: embeddedConfig,\r\n      resolvedPath: fromFileUrl(import.meta.resolve('../.cli.json')),\r\n      remainingArgs,\r\n    };\r\n  }\r\n\r\n  async LoadInitFn(\r\n    initPath: string\r\n  ): Promise<{ initFn: CLIInitFn | undefined; resolvedInitPath: string }> {\r\n    {{#if importInitFn}}\r\n    return {\r\n      initFn: embeddedInit,\r\n      resolvedInitPath: fromFileUrl(import.meta.resolve(\"{{importInitFn}}\")),\r\n    };\r\n    {{else}}\r\n    return {\r\n      initFn: undefined,\r\n      resolvedInitPath: fromFileUrl(import.meta.resolve(initPath)),\r\n    };\r\n    {{/if}}\r\n  }\r\n\r\n  async LoadCommandModule(path: string): Promise<CommandModule> {\r\n    const key = Object.entries(embeddedCommandEntries).find(\r\n      ([_, entry]) => (entry as any).CommandPath && (entry as any).CommandPath === path,\r\n    )?.[0];\r\n\r\n    if (!key) {\r\n      throw new Error(`‚ùå No embedded command key found for path: ${path}`);\r\n    }\r\n\r\n    let mod = (EmbeddedCommandModules as any)[key];\r\n\r\n    if (!mod) {\r\n      throw new Error(`‚ùå No embedded command module found for key: ${key}`);\r\n    }\r\n\r\n    if (mod instanceof CommandModuleBuilder) mod = mod.Build();\r\n    return mod as CommandModule;\r\n  }\r\n\r\n  async ResolveTemplateLocator(\r\n    _dfsHandler?: DFSFileHandler,\r\n  ): Promise<TemplateLocator | undefined> {\r\n    return new EmbeddedTemplateLocator(\r\n      embeddedTemplates as Record<string, string>,\r\n    );\r\n  }\r\n}\r\n",
  "cli-build-static/EmbeddedCommandModules.ts.hbs": "{{! embedded-commands.ts.hbs }}\r\n\r\n{{#each imports}}\r\nimport {{alias}} from \"{{path}}\";\r\n{{/each}}\r\n\r\nexport const EmbeddedCommandModules = {\r\n{{#each modules}}\r\n  \"{{key}}\": {{alias}},\r\n{{/each}}\r\n};\r\n",
  "cli-compile/install.ts.hbs": "import { join } from \"https://deno.land/std@0.207.0/path/mod.ts\";\r\n\r\nconst home = Deno.env.get(Deno.build.os === \"windows\" ? \"USERPROFILE\" : \"HOME\")!;\r\nconst defaultBinDir = \"{{defaultBinDir}}\".replace(\"~\", home);\r\nconst binDir = Deno.args[0] ?? defaultBinDir;\r\nconst isWindows = \"{{platform}}\" === \"windows\";\r\n\r\nawait Deno.mkdir(binDir, { recursive: true });\r\n\r\nconst cliBinary = \"./{{binaryName}}\" + (isWindows ? \".exe\" : \"\");\r\nconst targetBinary = join(binDir, \"{{binaryName}}\" + (isWindows ? \".exe\" : \"\"));\r\n\r\nawait Deno.copyFile(cliBinary, targetBinary);\r\nconsole.log(\"‚úÖ Installed\", targetBinary);\r\n\r\n// Setup aliases\r\n{{#each aliases}}\r\n{\r\n  const alias = \"{{this}}\";\r\n  const ext = isWindows ? \".cmd\" : \"\";\r\n  const aliasPath = join(binDir, alias + ext);\r\n  const content = isWindows\r\n    ? `@echo off\\\\n{{binaryName}}.exe %*`\r\n    : `#!/bin/sh\\\\nexec {{binaryName}} \"$@\"`;\r\n\r\n  await Deno.writeTextFile(aliasPath, content);\r\n  if (!isWindows) await Deno.chmod(aliasPath, 0o755);\r\n  console.log(\"üîó Alias installed:\", alias);\r\n}\r\n{{/each}}\r\n\r\n// PATH guidance\r\nconst pathEnv = Deno.env.get(\"PATH\") ?? \"\";\r\nconst sep = isWindows ? \";\" : \":\";\r\nif (!pathEnv.split(sep).includes(binDir)) {\r\n  console.warn(\"\\\\n‚ö†Ô∏è  ${binDir} is not in your PATH.\");\r\n  console.info(\"üëâ Add it to your shell profile to use CLI globally.\");\r\n}\r\n",
  "cli-run/cli-runner.ts.hbs": "import { CLI } from \"@fathym/common/cli\";\r\n\r\nconst cli = new CLI({});\r\nawait cli.RunFromArgs(Deno.args);\r\n",
  "hello/.cli.init.ts.hbs": "import { CLIInitFn } from '@fathym/common/cli';\r\n\r\nexport interface SayHello {\r\n  Speak(name: string): string;\r\n}\r\n\r\nexport class DefaultSayHello implements SayHello {\r\n  Speak(name: string): string {\r\n    return `Hello, ${name}!`;\r\n  }\r\n}\r\n\r\nexport default (async (ioc, _config) => {\r\n  ioc.Register(() => new DefaultSayHello(), {\r\n    Type: ioc.Symbol('SayHello'),\r\n  });\r\n}) as CLIInitFn;\r\n",
  "hello/.cli.json.hbs": "{\r\n  \"Name\": \"My CLI\",\r\n  \"Tokens\": [\"my-cli\"],\r\n  \"Version\": \"0.0.0\",\r\n  \"Description\": \"A Test CLI used for whatever you need.\"\r\n}\r\n",
  "hello/.gitignore.hbs": ".env\n.build/\ncov/\n.dist/\n.temp/\n",
  "hello/.vscode/settings.json.hbs": "{\r\n  \"deno.enable\": true,\r\n  \"deno.lint\": true,\r\n  \"editor.defaultFormatter\": \"denoland.vscode-deno\",\r\n  \"deno.config\": \"./deno.jsonc\",\r\n  \"[typescriptreact]\": {\r\n    \"editor.defaultFormatter\": \"denoland.vscode-deno\"\r\n  },\r\n  \"[typescript]\": {\r\n    \"editor.defaultFormatter\": \"denoland.vscode-deno\"\r\n  },\r\n  \"[javascriptreact]\": {\r\n    \"editor.defaultFormatter\": \"denoland.vscode-deno\"\r\n  },\r\n  \"[javascript]\": {\r\n    \"editor.defaultFormatter\": \"denoland.vscode-deno\"\r\n  },\r\n  \"json.schemas\": [\r\n    {\r\n      \"fileMatch\": [\"**/.cli.json\"],\r\n      \"url\": \"https://jsr.io/@fathym/common/0.2.201/schemas/CLIConfig.schema.json\"\r\n    },\r\n    {\r\n      \"fileMatch\": [\"**/.metadata.json\"],\r\n      \"url\": \"https://jsr.io/@fathym/common/0.2.201/schemas/CommandModuleMetadata.schema.jsons\"\r\n    }\r\n  ]\r\n}\r\n",
  "hello/commands/hello.ts.hbs": "import { z } from '@fathym/common/third-party/zod';\nimport { Command, CommandParams } from '@fathym/common/cli';\nimport type { SayHello } from '../.cli.init.ts';\n\nconst HelloFlagsSchema = z.object({\n  loud: z.boolean().optional().describe('Shout the greeting'),\n  'dry-run': z\n    .boolean()\n    .optional()\n    .describe('Show the message without printing'),\n});\n\nconst HelloArgsSchema = z.tuple([\n  z.string().optional().describe('Name to greet'),\n]);\n\nclass HelloCommandParams extends CommandParams<\n  z.infer<typeof HelloArgsSchema>,\n  z.infer<typeof HelloFlagsSchema>\n> {\n  get Name(): string {\n    return this.Arg(0) ?? 'world';\n  }\n\n  get Loud(): boolean {\n    return this.Flag('loud') ?? false;\n  }\n}\n\nexport default Command('hello', 'Prints a friendly greeting.')\n  .Args(HelloArgsSchema)\n  .Flags(HelloFlagsSchema)\n  .Params(HelloCommandParams)\n  .Services(async (_, ioc) => ({\n    SayHello: await ioc.Resolve<SayHello>(ioc.Symbol('SayHello')),\n  }))\n  .Run(async ({ Params, Log, Services }) => {\n    const sayHelloSvc = await Services.SayHello;\n\n    let message = sayHelloSvc.Speak(Params.Name);\n\n    if (Params.Loud) {\n      message = message.toUpperCase();\n    }\n\n    if (Params.DryRun) {\n      Log.Info(`üõë Dry run: \"${message}\" would have been printed.`);\n    } else {\n      Log.Info(`üëã ${message}`);\n    }\n  });\n",
  "hello/commands/wave.ts.hbs": "import { z } from '@fathym/common/third-party/zod';\r\nimport {\r\n  type CommandContext,\r\n  CommandParams,\r\n  CommandRuntime,\r\n  defineCommandModule,\r\n} from '@fathym/common/cli';\r\n\r\n// üß© Define schemas\r\nconst WaveFlagsSchema = z.object({\r\n  excited: z.boolean().optional().describe('Add extra enthusiasm to the wave'),\r\n  'dry-run': z\r\n    .boolean()\r\n    .optional()\r\n    .describe('Show the wave without printing it'),\r\n});\r\n\r\nconst WaveArgsSchema = z.tuple([\r\n  z.string().optional().describe('Name to wave at'),\r\n]);\r\n\r\n// üß© Parameter class\r\nclass WaveCommandParams extends CommandParams<\r\n  z.infer<typeof WaveArgsSchema>,\r\n  z.infer<typeof WaveFlagsSchema>\r\n> {\r\n  get Name(): string {\r\n    return this.Arg(0) ?? 'friend';\r\n  }\r\n\r\n  get Excited(): boolean {\r\n    return this.Flag('excited') ?? false;\r\n  }\r\n}\r\n\r\n// üöÄ Command logic\r\nexport class WaveCommand extends CommandRuntime<WaveCommandParams> {\r\n  public Run(ctx: CommandContext<WaveCommandParams>): Promise<void> {\r\n    const { Name, Excited, DryRun } = ctx.Params;\r\n    const { Log } = ctx;\r\n\r\n    let message = `üëã Waving at ${Name}`;\r\n    if (Excited) message += '!!!';\r\n\r\n    if (DryRun) {\r\n      Log.Info(`üõë Dry run: \"${message}\" would have been printed.`);\r\n    } else {\r\n      Log.Info(message);\r\n    }\r\n\r\n    return Promise.resolve();\r\n  }\r\n\r\n  public BuildMetadata() {\r\n    return this.buildMetadataFromSchemas(\r\n      'Wave',\r\n      'Waves at a friend with optional excitement.',\r\n      WaveArgsSchema,\r\n      WaveFlagsSchema\r\n    );\r\n  }\r\n}\r\n\r\nexport default defineCommandModule({\r\n  FlagsSchema: WaveFlagsSchema,\r\n  ArgsSchema: WaveArgsSchema,\r\n  Params: WaveCommandParams,\r\n  Command: WaveCommand,\r\n});\r\n",
  "hello/deno.jsonc.hbs": "{\r\n  \"imports\": {\r\n    \"@fathym/common\": \"jsr:@fathym/common@0\"\r\n  },\r\n  \"lock\": false\r\n}\r\n",
  "hello/intents/.intents.ts.hbs": "import './hello.intents.ts';\r\nimport './wave.intents.ts';\r\n",
  "hello/intents/hello.intents.ts.hbs": "import { CommandIntents } from '@fathym/common/cli';\nimport HelloCommand from '../commands/hello.ts';\nimport initFn from '../.cli.init.ts';\n\nconst cmd = HelloCommand.Build();\nconst origin = import.meta.resolve('../.cli.json');\n\nCommandIntents('Hello Command Suite', cmd, origin)\n  .WithInit(initFn)\n  .Intent('Greet default world', (int) =>\n    int\n      .Args([undefined])\n      .Flags({})\n      .ExpectLogs('üëã Hello, world')\n      .ExpectExit(0),\n  )\n  .Intent('Greet a specific name', (int) =>\n    int\n      .Args(['me'])\n      .Flags({})\n      .ExpectLogs('üëã Hello, me')\n      .ExpectExit(0),\n  )\n  .Intent('Greet loudly', (int) =>\n    int\n      .Args(['team'])\n      .Flags({ loud: true })\n      .ExpectLogs('üëã HELLO, TEAM')\n      .ExpectExit(0),\n  )\n  .Intent('Dry run greeting', (int) =>\n    int\n      .Args(['sandbox'])\n      .Flags({ 'dry-run': true })\n      .ExpectLogs('üõë Dry run: \"Hello, sandbox!\" would have been printed.')\n      .ExpectExit(0),\n  )\n  .Intent('Dry run loud greeting', (int) =>\n    int\n      .Args(['everyone'])\n      .Flags({ 'dry-run': true, loud: true })\n      .ExpectLogs('üõë Dry run: \"HELLO, EVERYONE!\" would have been printed.')\n      .ExpectExit(0),\n  )\n  .Run();\n",
  "hello/intents/wave.intents.ts.hbs": "import { CommandIntent } from '@fathym/common/cli';\nimport WaveCommand from '../commands/wave.ts';\n\nconst origin = import.meta.resolve('../.cli.json');\n\n// ‚úÖ Default wave (no args, no flags)\nCommandIntent('waves at default friend', WaveCommand, origin)\n  .Args([undefined])\n  .Flags({})\n  .ExpectLogs('üëã Waving at friend')\n  .ExpectExit(0)\n  .Run();\n\n// ‚úÖ Wave with a name\nCommandIntent('waves at a specific person', WaveCommand, origin)\n  .Args(['me'])\n  .Flags({})\n  .ExpectLogs('üëã Waving at me')\n  .ExpectExit(0)\n  .Run();\n\n// ‚úÖ Wave with excitement\nCommandIntent('waves excitedly', WaveCommand, origin)\n  .Args(['you'])\n  .Flags({ excited: true })\n  .ExpectLogs('üëã Waving at you!!!')\n  .ExpectExit(0)\n  .Run();\n\n// ‚úÖ Dry run suppresses actual wave\nCommandIntent('dry run prevents wave from printing', WaveCommand, origin)\n  .Args(['nobody'])\n  .Flags({ 'dry-run': true })\n  .ExpectLogs('üõë Dry run: \"üëã Waving at nobody\" would have been printed.')\n  .ExpectExit(0)\n  .Run();\n\n// ‚úÖ Dry run + excited together\nCommandIntent('dry run with excitement', WaveCommand, origin)\n  .Args(['the crowd'])\n  .Flags({ 'dry-run': true, excited: true })\n  .ExpectLogs('üõë Dry run: \"üëã Waving at the crowd!!!\" would have been printed.')\n  .ExpectExit(0)\n  .Run();\n"
}